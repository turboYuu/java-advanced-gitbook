> 第五部分 Redis高可用方案

"高可用性"（High Availability）通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。

单机的 Redis 是无法保证高可用性的，当 Redis 服务器宕机后，即使在有持久化的机制下也无法保证不丢失数据。

所以我们采用 Redis 多机和集群的方式来保证 Redis 的高可用性。

# 1 主从复制

Redis支持主从复制功能，可以通过执行slaveof（Redis 5 以后改成replicaof）或者配置文件中设置slaveof（Redis 5以后改成replicaof）来开启复制功能。

![image-20220927171020446](assest/image-20220927171020446.png)

![image-20220927171052334](assest/image-20220927171052334.png)

![image-20220927171122688](assest/image-20220927171122688.png)

- 主对外 从对内，主可写，从不可写
- 主挂了，从不可为主

## 1.1 主从配置

### 1.1.1 主Redis配置

无需特殊配置

### 1.1.2 从Redis配置

（安装后的redis 使用  `cp -r redis redis-slave-6380` 复制出一个redis）

修改从服务器上的`redis.conf`文件：

```properties
# replicaof <masterip> <masterport>
# 表示当前【从服务器】对应的【主服务器】的ip是192.168.31.135，端口号是6379
replicaof 127.0.0.1 6379
```

```bash
[root@localhost bin]# ./redis-cli -p 6380
127.0.0.1:6380> set lock 20
(error) READONLY You can't write against a read only replica.
```

## 1.2 作用

### 1.2.1 读写分离

- 一主多从，主从同步。

- 主负责写，从负责读。

- 提升Redis的性能和吞吐量。

- 主从的数据一致性问题。

### 1.2.2 数据容灾

- 从机是主机的备份。
- 主机宕机，从机可读不可写。
- 默认情况下主机宕机后，从机不可为主机。
- 利用**哨兵**可以实现主从切换，做到高可用。

## 1.3 原理与实现

### 1.3.1 复制流程

#### 1.3.1.1 保存主节点信息

当客户端向从服务器发送 slaveof(replicaof) 主机地址（127.0.0.1）端口（6379）时：从服务器将主机IP（127.0.0.1）和 端口（6379）保存到 redisServer 的 masterhost 和 masterprot 中。

```c
Struct redisServer{
	char *masterhost; 	//主服务器ip   
	int  masterport; 	//主服务器端口 
};
```

从服务器将向发送 SLAVEOF  命令的客户端返回 OK，表示复制指令已经被接收，而实际上复制工作是在 OK 返回之后进行。

#### 1.3.1.2 建立 socket 链接

slaver 与 master 建立 socket 链接。

slaver 关联文件事件处理器。

该处理器接收 RDB 文件（全量复制）、接收 Master 传播来的写命令（增量复制）

![image-20220419135444484](assest/image-20220419135444484.png)

主服务器 accept 从服务器 socket 连接后，创建相应的客户端状态。相当于从服务器是主服务器的 Client 端。

![image-20220419135939187](assest/image-20220419135939187.png)

#### 1.3.1.3 发送 ping 命令

**Slaver 向 Master 发送 ping 命令**

1. 检测 socket 的读写状态
2. 检测 Master 能否正常处理

**Master 的响应**：

1. 发送 “pong” ，说明正常
2. 返回错误，说明 Master 不正常
3. timeout，说明网络超时

![image-20220419140544467](assest/image-20220419140544467.png)

#### 1.3.1.4 权限验证

主从正常连接后，进行权限验证

**主**未设置密码（requirepass=""），**从** 也不用设置密码（masterauth=""）

**主**设置密码（requirepass!=""）， **从**需要设置密码（masterauth=主的requirepass的值）

或者 **从** 通过 auth 命令向 **主** 发送密码。

![image-20220927172428077](assest/image-20220927172428077.png)

![image-20220419143333929](assest/image-20220419143333929.png)

#### 1.3.1.5 发送端口信息

在身份验证步骤之后，从服务器将执行命令 REPLCONF listening-port，向主服务器发送从服务器的监听端口号。

![image-20220419143625737](assest/image-20220419143625737.png)

#### 1.3.1.6 同步数据

Redis 2.8 之后分为全量同步 和 增量同步，具体的后面详细讲解。

#### 1.3.1.7 命令传播

当同步数据完成后，主从服务器就会进入命令传播阶段，主服务器只要将自己执行的写命令发送给从服务器，而从服务器只要一直执行并接收主服务器发来的写命令。

### 1.3.2 同步数据集

Redis 2.8 以前使用 SYNC 命令同步复制

Redis 2.8 之后使用 PSYNC 命令替换 SYNC

#### 1.3.2.1 旧版本

Redis 2.8 以前

##### 1.3.2.1.1 实现方式

Redis 的同步功能分为 同步（sync）和 命令传播（command propagate）

###### 1.3.2.1.1.1 同步操作

1. 通过从服务器发送到 SYNC 命令给主服务器
2. 主服务器生成 RDB 文件并发送给从服务器，同时发送保存所有写命令给从服务器
3. 从服务器清空之前数据并执行解析 RDB 文件。
4. 保持数据一致（还需要命令传播过程才能保持一致）

![image-20220419154438228](assest/image-20220419154438228.png)

###### 1.3.2.1.1.2 命令传播操作

同步操作完成后，主服务器执行写命令，该命令发送给从服务器并执行，使主从保持一致。

##### 1.3.2.1.2 缺陷

没有 全量同步 和 增量同步 的概念，从服务器在同步时，会清空所有数据。

主从服务器断线后重新复制，主服务器会重新生成 RDB 文件和重新记录缓冲区的所有写命令，并全量同步到从服务器上。



#### 1.3.2.2 新版本

Redis 2.8 以后

##### 1.3.2.2.1 实现方式

在 Redis 2.8 之后使用 PSYNC 命令，具备 完整重同步 和 部分重同步 模式。

- Redis 的主从同步，分为 **全量同步** 和 **增量同步**。

- 只有从服务器第一次连接上主机是 **全量同步**。

- 断线重连有可能触发 **全量同步** 也有可能是 **增量同步**（`master` 判断 `runid` 是否一致）。

  ![image-20220419162333073](assest/image-20220419162333073.png)

- 除此之外的情况都是 **增量同步**。

###### 1.3.2.2.1.1 全量同步

Redis 的 全量同步过程主要分为三个阶段：

- **同步快照阶段**：Master 创建并发送 **快照** RDB 给 Slave，Slave 载入并解析快照。Master 同时将此阶段所产生的新的写命令存储到缓冲区。
- **同步写缓冲阶段**：Master 向 Slave 同步存储在缓冲区的写操作命令。
- **同步增量阶段**：Master 向 Slave 同步写操作命令。

![image-20220419165046745](assest/image-20220419165046745.png)



###### 1.3.2.2.1.2 增量同步

- Redis 增量同步主要指 Slave 完成初始化后开始正常工作时，Master 发生的写操作同步到 Slave 的过程。
- 通常情况下，Master 每执行一个写命令就会向 Slave 发送相同的 **写命令**，然后 Slave 接收并执行。

### 1.3.3 心跳检测

在命令传播阶段，从服务器默认会以每秒一次的频率向主服务器发送命令：

```properties
replconf ack <replication_offset>
    
#ack :应答
#replication_offset：从服务器当前的复制偏移量
```

主要作用有三个：

1. 检测主从的连接状态

   检测主从服务器的网络连接状态

   通过向主服务器发送 INFO replication 命令，可以列出从服务器列表，可以看出最后一次向主发送命令距离现在过了多少秒。lag 的值应该在 0 或 1 之间跳动，如果超过 1 则说明主从之间的连接有故障。

   ![image-20220927173711796](assest/image-20220927173711796.png)

2. 辅助实现 min-slaves

   ![image-20220927173303392](assest/image-20220927173303392.png)

   Redis 可以通过配置防止主服务器在不安全的情况下执行写命令

   min-replicas-to-write 3 （min-replicas-to-write 3）

   min-replicas-max-lag 10 （min-replicas-max-lag 10）

   上面的配置表示：从服务器的数量少于 3 个，或者3个从服务器的延迟（lag）值都大于或等于10秒时，主服务器将拒绝执行写命令。这里的延迟值就是上面 `info replication` 命令的 lag 值。

3. 检测命令丢失

   如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么当从服务器向主服务器发送 REPLCONF ACK 命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器。（补发：网络不断）。

   增量同步：网断了，再次连接

# 2 哨兵模式

## 2.1 部署方案

## 2.2 搭建配置

## 2.3 执行流程

## 2.4 哨兵 leader 选举

## 2.5 主服务器的选择

# 3 集群与分区

## 3.1 分区的意义

## 3.2 分区的方式

## 3.3 client 端分区

## 3.4 proxy 端分区

## 3.5 官方 cluster 分区