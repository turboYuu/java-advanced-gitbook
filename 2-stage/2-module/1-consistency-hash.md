> 第一部分 一致性Hash算法

Hash 算法，在安全加密领域 MD5、SHA 等加密算法，在数据存储和查找方面有 Hash 等，以上都应用到了 Hash 算法。

为什么需要使用 Hash？

Hash 算法较多的应用在数据存储和查找领域，最经典的就是 Hash 表，它的查询效率非常之高，其中哈希算法如果设计的比较 :ok_hand: 的话，那么Hash表的数据查询时间复杂度可以接近于 O(1)，示例：

```
需求：提供一组数据 `1, 5, 7, 6, 3, 4, 8`，对这组数据进行存储，
然后随便给定一个数 n，请你判断 n 是否存在于数据集 list:List[1, 5, 7, 6, 3, 4, 8] 中
```

1. 通过循环判断来实现

   ```java
   for(int element:list){
       if(element == n){
           // 如果相等，说明n存在于数据集中
       }
   }
   ```

   这种方法叫做 **顺序查找法**：这种方式通过循环完成，比较原始，效率低

2. 二分查找

   排序之后折半查找，相对于顺序查找法会提高效率，但是效率也并不是很好



当然 可以不循环，不二分。

![image-20220707152736457](assest/image-20220707152736457.png)

定义一个数组，数组长度等于数据集长度，此处长度为 9，数据1就在下标为1的位置，3就在下标为3的位置，以此类推。

这时，判断 5 是否存在，只需要判断 array[5] 是否为空，若为空，说明 5 不存在；若不为空，则说明5存在。通过一次查询就达到目的，时间复杂度为 O(1)。

这种方式叫做 **直接寻址法**：直接把数据和数组下标绑定到一起，查找的时候，直接 array[n] 就可以取出数据。

优点：速度快，一次查找得到结果

缺点：

1. 浪费空间，比如 1,5,7,6,3,4,8,12308，最大值 12308，按照上述方式需要定义一个长度为 12309 的数组，但只存储零星数据，其他都浪费。
2. 数据如：1,5,3,4,8,12,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2 最大值12，开辟 13 个空间存储不下。



现在换一种涉及，如果数据是 3，5，7，12306，一共 4 个数据，开辟任意个空间，比如 5 个，根据求模取余确定存储位置的下标。

![image-20220707154051431](assest/image-20220707154051431.png)

数据%空间长度，就是一种 hash 算法，只不过这是一种比较普通又简单的 hash 算法，这种构造Hash算法的方式叫做除留余数法。

如果数据是 1，6，7，8，把这4个数据存储到上面的数组中：

![image-20220707154602166](assest/image-20220707154602166.png)

在此基础上采用开放寻址法（了解即可）

**开放寻址法**：1放进去了，6再来的时候，向前或者向后找空闲位置存放。不好的地方：定义好的数组长度不能扩展，那么不管Hash冲不冲突，数据多了就存不下。

**拉链法**：数据长度定义好了，怎么存储更多的内容？算好 hash 值，在数据元素存储位置放一个链表。

![image-20220707155404585](assest/image-20220707155404585.png)

如果 Hash 算法设计的比较好的话，那么查询效率会更接近于 O(1)，如果 Hash 算法设计的比较 low，那么查询效率就会很低。

所以，Hash表的查询效率高不高取决于hash算法，hash算法能够让数据平均分布，即能节省空间又能提高查询效率。Hash 算法的研究是很深的一门学问。比较复杂，长久以来，Hash表内部的hash算法也一直在更新，很多数学家也在研究。

```xml
除留余数法
线性构造hash算法
直接寻址法也是一种构造hash的方式，只不过更简单，表达式：H(key)=key，比如H(key)=a*key+b (a,b是常量)
hashcode其实也是通过hash算法得出来的
```

# 1 Hash算法应用场景

# 2 普通Hash算法存在的问题

# 3 一致性Hash算法

# 4 手写实现一致性Hash算法

# 5 Nginx配置一致性 Hash 负载均衡策略

