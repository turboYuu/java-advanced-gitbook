> 第三部分 MySQL事务和锁

# 1 ACID 特性

[InnoDB and the ACID Model](https://dev.mysql.com/doc/refman/5.7/en/mysql-acid.html)

在关系型数据库管理系统中，一个逻辑工作单元要完成事务，必须满足这 4 个特性，即所谓的 ACID：Atomicity、Consistency、Isolation、Durability。

## 1.1 原子性

原子性：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全不执行。

修改 ---> Buffer Pool 修改 ---> 刷盘。可能有下面两种情况：

- 事务提交了，如果此时 Buffer Pool 的脏页没有刷盘，如何保证修改的数据生效？Redo
- 如果事务没提交，但是Bufer Pool 的脏页刷盘了，如何保证不该存在的数据撤销？Undo

每一个写事务，都会修改 Buffer Pool，从而产生相应的 Redo/Undo 日志，在 Buffer Pool 中的也被刷到磁盘之前，这些日志信息都会先写入到日志文件中，如果 Buffer Pool 中的脏页没有刷成功，此时数据库挂了，那再数据库再次启动之后，可以通过 Redo 日志将其恢复出来，以保证脏页写的数据不会丢失。如果脏页刷新成功，此时数据库挂了，就需要通过 Undo 来实现了。

## 1.2 持久性

持久性：指的是一个事务一旦提交，它对数据库中数据的改变就应该是永久的，后续的操作或故障不应该对其有任何影响，不会丢失。

MySQL 的持久性 也与 **WAL** 技术相关，redo log 在系统 Crash 重启之类的情况时，可以修复数据，从而保障事务的持久性。通过原子性可以保证逻辑上的持久性，通过存储引擎的数据刷盘可以保证物理上的持久性。

## 1.3 隔离性

隔离性：指的是一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对其他的并发事务是隔离的。

InnoDB 支持的隔离性有 4 种，隔离性从低到高分别为：读未提交、读提交、可重复读、可串行化。锁和多版本控制（MVCC）技术就是用于保障隔离性的。

## 1.4 一致性

一致性：指的是事务开始之前和事务结束之后，数据库的完整性限制未被破坏。一致性包括两方面的内容，分别是约束一致性 和 数据一致性。

- 约束一致性：创建表结构时所指定的外键、Check、唯一索引等约束，可惜在 MySQL 中不支持 Check。
- 数据一致性：是一个综合性的规定，因为它是由原子性、持久性、隔离性 共同保证的结果，而不是单单依赖于某一种技术。

一致性也可以理解为数据的完整性。数据的完整性是通过原子性、隔离性、持久性来保证的，而这三个特性又是通过 Redo/Undo 来保证的。逻辑上的一致性，包括 唯一索引、外键约束、check约束，这属于业务逻辑范畴。

![image-20220913115116566](assest/image-20220913115116566.png)

ACID 及它们之间的关系如下图所示，4 个特性中有 3 个 与 WAL 有关，都需要通过 Redo、Undo 日志来保证等。

WAL 的全称 Write-Ahead Logging，先写日志，再写磁盘。

![image-20220913121024953](assest/image-20220913121024953.png)



# 2 事务控制的演进

## 2.1 并发事务

事务并发处理可能会带来一些问题，比如：更新丢失、脏读、不可重复读、幻读等。

- 更新丢失

  当两个或多个事务更新同一行记录，会产生更新丢失现象。可以分为回滚覆盖和提交覆盖。

  - 回滚覆盖：一个事务回滚操作，把其他事务已提交的数据给覆盖了。
  - 提交覆盖：一个事务提交操作，把其他事务已提交的数据给覆盖了。

- 脏读

  一个事务读取到了另一个事务修改但未提交的数据。（update）

- 不可重复读

  一个事务中多次读取同一行记录不一致，后面读取的和前面读取的不一致。

- 幻读

  一个事务中多次按相同条件查询，结果不一致。后续查询的结果 和 前面查询的结果不同，多了或少了几行记录。（insert、delete）



## 2.2 排队

最简单的方法，就是完全顺序执行左右事务的数据库操作，不需要加锁，简单的说就是全局排队。序列化执行所有的事务单元，数据库某个时刻只处理一个事务操作，特点是强一致性，处理性能低。

![image-20220913140544403](assest/image-20220913140544403.png)



## 2.3 排他锁

引入锁之后就可以支持并发处理事务，如果事务之间涉及到相同的数据项时，会使用排他锁，或叫互斥锁，先进入的事务独占数据项以后，其他事务被阻塞，等待前面的事务释放锁。

![image-20220913141141090](assest/image-20220913141141090.png)

注意，在整个事务1 结束之前，锁是不会被释放的。所以，事务2 必须等到事务1 结束之后开始。

## 2.4 读写锁

读和写操作：读读、写写、读写、写读。

读写锁就是进一步细化锁的粒度，区分读操作和写操作，让读和读之间不加锁，这样下面的两个事务就可以同时被执行了。

![image-20220913141939609](assest/image-20220913141939609.png)

读写锁，可以让读和读并行，而读和写、写和读、写和写这几种之间还是要加排他锁。

## 2.5 MVCC

多版本控制 MVCC，也就是 Copy on Write 的思想。MVCC 除了支持读和读的并行，还支持 读和写、写和读 的并行，但为了保证一致性，写和写是无法并行的。

![image-20220913142802382](assest/image-20220913142802382.png)

在事务1 开始写操作的时候会 copy 一个记录的副本，其他事务读操作会读取这个记录副本，因此不会影响其他事务对此记录的读取，实现写和读并行。

# 3 事务隔离级别

## 3.1 隔离级别类型

## 3.2 MySQL 隔离级别控制

# 4 锁机制和实战

## 4.1 锁分类

## 4.2 行锁原理

## 4.3 悲观锁

## 4.4 乐观锁

## 4.5 死锁与解决方案